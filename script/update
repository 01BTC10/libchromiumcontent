#!/usr/bin/env python

import contextlib
import errno
import os
import shutil
import subprocess
import tarfile
import tempfile
import urllib2


SOURCE_ROOT = os.path.abspath(os.path.dirname(os.path.dirname(__file__)))
VENDOR_DIR = os.path.join(SOURCE_ROOT, 'vendor')
DEPOT_TOOLS_DIR = os.path.join(VENDOR_DIR, 'depot_tools')
CHROMIUM_DIR = os.path.join(VENDOR_DIR, 'chromium')
SRC_DIR = os.path.join(CHROMIUM_DIR, 'src')
CHROMIUMCONTENT_SOURCE_DIR = os.path.join(SOURCE_ROOT, 'chromiumcontent')
CHROMIUMCONTENT_DESTINATION_DIR = os.path.join(SRC_DIR, 'chromiumcontent')

TARBALL_REPO = 'zcbenz/chromium-source-tarball'
TARBALL_URL = 'https://github.com/{0}/releases/download/{1}/chromium-{1}.tar.xz'


def main():
  version = chromium_version()
  if not is_source_tarball_updated(version):
    download_source_tarball(version)

  return

  return (# Make sure we get all of the branches locally.
          gclient_sync(True) or
          # Update top-level checkout to the release tag.
          checkout_version() or
          # Update deps for current checkout.
          gclient_sync(False) or
          apply_patches() or
          copy_chromiumcontent_files() or
          run_gyp() or
          install_win_tool_wrapper())


def chromium_version():
  with open(os.path.join(SOURCE_ROOT, 'VERSION')) as f:
    return f.readline().strip()


def is_source_tarball_updated(version):
  version_file = os.path.join(SRC_DIR, '.version')
  existing_version = ''
  try:
    with open(version_file, 'r') as f:
      existing_version = f.readline().strip()
  except IOError as e:
    if e.errno != errno.ENOENT:
      raise
    return False
  return existing_version == version


def download_source_tarball(version):
  rm_rf(SRC_DIR)

  tar_name = 'chromium-{0}.tar'.format(version)
  xz_name = tar_name + '.xz'
  url = TARBALL_URL.format(TARBALL_REPO, version)
  with open(xz_name, 'w+') as t:
    with contextlib.closing(urllib2.urlopen(url)) as u:
      while True:
        chunk = u.read(1024*1024)
        if not len(chunk):
            break
        sys.stderr.write('.')
        sys.stderr.flush()
        t.write(chunk)

  sys.stderr.write('\nExtracting...\n')
  sys.stderr.flush()
  subprocess.check_call(['xz', '-dk', filename])


def checkout_version():
    os.chdir(SRC_DIR)
    return subprocess.call(['git', 'checkout', '-f',
                            'refs/tags/{0}'.format(chromium_version())])


def gclient_sync(nohooks):
    os.chdir(SRC_DIR)
    gclient = os.path.join(DEPOT_TOOLS_DIR, 'gclient.py')
    args = [sys.executable, gclient, 'sync', '--with_branch_heads']
    if nohooks:
        args += ['--nohooks']
    if subprocess.call(args, env=gyp_env()):
        return subprocess.call(args + ['--force'], env=gyp_env())


def gyp_env():
    env = os.environ.copy()

    # Some gclient hooks assume that depot_tools is on the path.
    env['PATH'] = os.path.pathsep.join([DEPOT_TOOLS_DIR, env['PATH']])

    # Disable NaCl. We don't need it, and it requires some very long filepaths
    # which often overrun the Windows file path limit.
    if 'disable_nacl=1' not in env.get('GYP_DEFINES', ''):
        env['GYP_DEFINES'] = ' '.join(['disable_nacl=1', env.get('GYP_DEFINES', '')])

    env['GYP_GENERATORS'] = 'ninja'

    if sys.platform == 'darwin':
        # Build 64-bit
        env['GYP_DEFINES'] = ' '.join(['host_arch=x64 target_arch=x64', env.get('GYP_DEFINES', '')])

        # Use Xcode's own clang instead of Chromium's. This matches what embedding
        # applications will use, reducing the risk of bugs due to version
        # mismatches.
        env['CC_target'] = 'clang'
        env['CXX_target'] = 'clang++'
    elif sys.platform in ['win32', 'cygwin']:
        # Don't use the auto-installed VS2013 Express toolchain from depot_tools.
        # We have our own.
        env['DEPOT_TOOLS_WIN_TOOLCHAIN'] = '0'
        env['GYP_MSVS_VERSION'] = '2013'

    return env


def copy_chromiumcontent_files():
    try:
        os.makedirs(CHROMIUMCONTENT_DESTINATION_DIR)
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise
    for dirpath, dirnames, filenames in os.walk(CHROMIUMCONTENT_SOURCE_DIR):
        for dirname in dirnames:
            mkdir_p(os.path.join(dirpath, dirname))
        for filename in filenames:
            source = os.path.join(dirpath, filename)
            relative = os.path.relpath(source, start=CHROMIUMCONTENT_SOURCE_DIR)
            destination = os.path.join(CHROMIUMCONTENT_DESTINATION_DIR, relative)
            if is_newer(destination, source):
                continue
            shutil.copy2(source, destination)


def apply_patches():
    # Applying patches can invoke gclient, which in turn can invoke gyp, so make
    # sure we have our gyp environment set.
    return subprocess.call([sys.executable, os.path.join(SOURCE_ROOT, 'script', 'apply-patches')], env=gyp_env())


def run_gyp():
    os.chdir(SRC_DIR)
    REL_CHROMIUMCONTENT_DESTINATION_DIR = os.path.relpath(CHROMIUMCONTENT_DESTINATION_DIR)

    python = [sys.executable]
    if sys.platform in ['win32', 'cygwin']:
      python = chromium_python()

    # gyp_chromium is executed with win32 python shipped by chromium, so it can
    # not understand POSIX-style paths, to make it work we pass must relative
    # paths to it.
    gyp = os.path.join('build', 'gyp_chromium')
    return subprocess.call(python +
                           [gyp, '-Ichromiumcontent/chromiumcontent.gypi',
                            os.path.join(REL_CHROMIUMCONTENT_DESTINATION_DIR,
                                         'chromiumcontent.gyp')],
                           env=gyp_env())


def install_win_tool_wrapper():
    if sys.platform not in ['win32', 'cygwin']:
        return
    for config in ['Debug', 'Release']:
        config_dir = os.path.join(SRC_DIR, 'out', config)
        win_tool = os.path.join(config_dir, 'gyp-win-tool')
        shutil.move(win_tool, '{0}-original'.format(win_tool))
        shutil.copy(os.path.join(SOURCE_ROOT, 'gyp-win-tool-wrapper'), win_tool)


def chromium_python():
    """Returns a command to execute the win32 python shipped by Chromium."""

    return ['cmd.exe', '/c', os.path.join(DEPOT_TOOLS_DIR, 'python.bat')]


def is_newer(destination, source):
    return os.path.exists(destination) and \
        os.path.getmtime(destination) > os.path.getmtime(source)


def rm_rf(path):
    try:
        shutil.rmtree(path)
    except OSError as e:
        if e.errno != errno.ENOENT:
            raise


def mkdir_p(path):
    try:
        os.makedirs(path)
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise


if __name__ == '__main__':
    import sys
    sys.exit(main())
